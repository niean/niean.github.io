---
layout: post
title: 软件工程之领域驱动设计
date: 2023-08-26 21:00
tags:
  - se
---

## 要点简述
- DDD适用于业务系统。DDD虽然设计套路僵化、但能定义底线，颇有文正公结硬寨打呆仗之妙
- DDD核心思想是分治。将复杂的、大规模的业务领域建模，统一语言、划分边界，然后分而治之，期望边界清晰、内核稳固(高内聚低耦合)
- DDD是动态演化过程。建模过程是不断猜想与反驳的过程，演化观点是建模过程的基本心智模式
- DDD建模几个关键词：业务场景，边界划分、通用语言，领域对象，领域建模。经典六边形架构，如下图
- ![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-arch-liubianxing.png)


## 基本概念
- DDD：Domain-Driven Design，领域驱动设计
    - 模型：DDD中的模型包括 领域、限界上下文、实体、值对象、聚合等
    - 关系：领域包含限界上下文，限界上下文包含子域，子域包含聚合，聚合包含实体和值对象
- 领域：Domain，业务范围和边界。领域分为核心、通用、支撑三类
    - 核心域：决定产品和公司核心竞争力的子域是核心域，直接对业务产生价值
    - 通用域：没有太多个性化诉求、被多个子域使用的通用功能子域是通用域，如权限、登陆，间接对业务产生价值
    - 支撑域：支撑其他领域业务、但不具有通用性，间接对业务产生价值
- 限界上下文：限界上下文即业务边界、类似微服务划分，它定义了该领域内部的通用语言、模型和规则
    - 目的：让不同领域/子领域，既能独立开发和演化、又能彼此交互和集成，类似微服务的高内聚低耦合理念
    - 形式：业务领域通常由多个子领域编排而成，限界上下文对其中的1+个子领域
    - 实现：高内聚低耦合，即一个限界上下文必须包括一个完整的业务流程(高内聚)、哪怕仅仅是子业务流程
- 实体：Entity，实体是对真实业务形态的抽象，实体有唯一标识、有生命周期、且具有延续性
    - 业务：实体能够反映业务的真实形态，是多个属性、操作或行为的载体
    - 代码：实体的代码有属性、行为(充血模型)，行为代表了大部分业务逻辑；只有属性、没有行为的成为贫血模型
    - 运行：实体有唯一不变的ID，属性可修改
- 值对象：值对象主要用于描述实体特征，是一些列属性的集合。值对象没有唯一ID、没有生命周期、不可修改。值对象和实体的区别举例如下图，
    - ![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-model-entryvo.jpg)
- 聚合：Aggregate，多个实体和值对象组成的东西叫聚合，聚合里面一定有一个实体是聚合根。
    - 聚合根：聚合根作用是保证内部的实体的一致性，外部操作只需要对阵聚合根
- 领域服务：DomainService
- 事件风暴：从琐碎到聚化的业务领域建模过程
    - 参与方：业务专家、产品经理、架构师、开发/测试
    - 关键点：业务的实体、命令、事件，实体执行命令后产生事件
    - 领域建模时，我们会根据场景分析过程中产生的领域对象，比如命令、事件等之间关系，找出产生命令的实体，分析实体之间的依赖关系组成聚合，为聚合划定限界上下文，建立领域模型以及模型之间的依赖。领域模型利用限界上下文向上可以指导微服务设计，通过聚合向下可以指导聚合根、实体和值对象的设计


## 数据对象
数据对象，大致分为如下几类：

- VO（View Object）视图对象
- DTO（Data Transfer Object）数据传输对象
- BO（Business Object）业务对象
- DO (Domain Object)：领域对象
- PO（Persistant Object）持久对象
- DAO（Data Access Object）数据访问对象

在DDD中，数据对象所处的分层及调用链路，大致如下。其中，BO对应领域向上游提供的API、DO对应领域向下游制定的SPI。

![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-model-data.jpg)


## 建模过程
DDD建模分为明确产品战略、梳理业务场景、换分技术领域、代码实现四个阶段，如下图。接下来以运维封线检查为例，介绍DDD建模的流程详情。

![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-model-steps.jpg)

①**明确产品战略**：确定产品目标，明确用户、价值、功能等宏观事项。

封线检查是变更管控的核心策略之一，功能是限制所有变更的时间窗口，价值是降低变更带来的质量风险，用户是公司所有员工、特别是RD。封线检查的难点是，定义一个通用策略、使能适用于所有变更系统。


②**梳理业务场景**：事件风暴，各个角色坐在一起头脑风暴，全面还原业务场景、精细梳理业务需求、得出一个大家都能看懂的事件风暴图。
事件风暴图类似有限状态机FSM，由业务流程、命令、事件三个行组成。业务流程是业务逻辑过程，最关键；命令是外部输入，可以是用户动作、外部系统触发、内部定时任务等；事件是命令执行或业务流程结果的输出，有主动、被动之分。

封线检查的事件风暴图，如下。通过业务讨论，封线检查域的业务流程包括封线策略的创建(含鉴权)、使用两个步骤。封线策略创建由管理员发起、属性包括服务对象、时段、等级，策略创建完成即可生效使用。使用方发起封线检查，告知被检查服务对象和时段，同过封线策略计算完成封线检查返回封线等级。

![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-model-event.jpg)


③**划分技术领域**：领域建模，包括 划分领域/子域、提炼聚合、抽象聚合根/实体/对象、以及限界上下文和事件等。实体对应业务对象，有业务属性和业务行为；值对象是属性集合、无行为。聚合是由业务和逻辑紧密关联的实体和值对象组合而成的，是数据修改和持久化的基本单元，对外提供某些领域服务；聚合根是提供领域服务的入口对象。限界上下文用来封装上下文环境的通用语言，保证领域内的术语含义明确、没有歧义，限界就是领域的边界、上下文则是语义环境。

聚合设计是领域建模的核心内容，重点讲一下。聚合设计的内容，包括将业务术语翻译为数据ER，将业务逻辑抽象为服务、接口、参数和对象，确定对象和对象之间的关系，确定对外提供服务的对象、内部依赖的对象、外部依赖的对象，根据依赖关系进一步划分聚合边界，等。聚合设计的原则，包括设计小聚合、封装业务不变性、通过唯一标识引用其他聚合、边界外使用最终一致性、通过应用层实现跨聚合服务调用等。

封线检查的领域模型，如下。封线检查对外提供策略创建、封线检查两个服务，这两个服务都围绕封线策略这个事项。策略创建由管理员实施；封线检查由使用方告知服务对象和时段，由封线策略服务根据该服务对象和时段匹配策略配置，计算封线等级。对外提供服务的不是策略配置、而是封线策略对象，封线策略对象 对内读写策略配置、进行逻辑计算，对外提供创建、检查两个领域服务 —— 封线策略对象就是聚合根，封线策略对象及其提供的服务就是封线聚合。使用方需要进行鉴权、判断他是否有权进行封线检查，封线策略对象通过RPC、调用权限域的鉴权服务(即所谓的事件)，封线策略聚合加上权限策略聚合、对外提供了完整的封线检查服务。

![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-model-model.jpg)


④**代码实现**：代码模型映射，代码规范落地。参见代码规范章节。


## 代码规范
待补充。


## 设计理念
- DDD架构：六边形架构，如下图
- ![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-arch-liubianxing.png)
- 分层架构：模块代码实现分为四层，自上而下分别是接口层、应用层、领域层、基础层。如下图，
- ![page.png](https://raw.githubusercontent.com/niean/niean.github.io/master/images/20230826/ddd-arch-fenceng.png)
- 适配器：以领域服务为中心，向上提供API、向下约定SPI；表现上，通过适配器和外部交互，将应用服务&领域服务封装在系统内部、和外部解耦
- 依赖倒置：即SPI；由领域层依赖基础层，倒置成基础层依赖领域层；这样，其它层都依赖领域层、领域层不依赖其它层，领域层最终只受限于业务逻辑
- 充血模型：将业务逻辑封装在领域对象内，不仅仅是简单的数据容器、还包含了与业务相关的行为规则
    - 表现形式：代码高内聚，属性对外不可见、只能通过方法访问和变更等
    - 贫血模型：与充血模型相对应的是贫血模型，它将业务逻辑放在外部服务或管理类中、领域对象仅仅是简单的数据结构
